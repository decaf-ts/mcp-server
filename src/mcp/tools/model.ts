import { Tool } from "fastmcp";
import path from "path";
import { readTextFile, writeTextFile, fileExists } from "../utils/fs";

export type DecoratorSpec = { name: string; args?: any[] };
export type AttributeSpec = {
  name: string;
  type: string;
  decorators?: DecoratorSpec[];
  optional?: boolean;
};

export type CreateOrUpdateModelArgs = {
  filePath: string; // absolute or relative path to .ts file
  className: string;
  properties?: AttributeSpec[];
  classDecorators?: DecoratorSpec[]; // e.g., [{name: "model"}, {name:"hashedBy", args:["default"]}]
  importsFrom?: string; // module specifier for validation decorators, default: "@decaf-ts/decorator-validation"
  overwrite?: boolean; // if true overwrites file; otherwise merges
};

function unique<T>(arr: T[]): T[] {
  return Array.from(new Set(arr));
}

function renderDecorator(d: DecoratorSpec) {
  const args = d.args?.length ? `(${d.args.map((a) => JSON.stringify(a)).join(", ")})` : "()";
  return `@${d.name}${args}`;
}

function genImports(imports: string[], from: string) {
  if (!imports.length) return "";
  return `import { ${unique(imports).sort().join(", ")} } from "${from}";\n`;
}

function generateModelSource(
  className: string,
  props: AttributeSpec[] = [],
  classDecorators: DecoratorSpec[] = [],
  importsFrom = "@decaf-ts/decorator-validation"
) {
  const propDecoratorNames = props.flatMap((p) => p.decorators?.map((d) => d.name) || []);
  const classDecoratorNames = classDecorators.map((d) => d.name);
  const importNames = unique(["model", ...propDecoratorNames, ...classDecoratorNames]);

  const header = `/* Auto-generated by @decaf-ts/mcp-server */\n${genImports(importNames, importsFrom)}\n`;

  const classDec = [ { name: "model" }, ...classDecorators ]
    .map(renderDecorator)
    .join("\n");

  const propsSrc = props
    .map((p) => {
      const decorators = (p.decorators || []).map(renderDecorator).join("\n");
      const optional = p.optional ? "?" : "";
      return `${decorators}${decorators ? "\n" : ""}${p.name}${optional}: ${p.type};`;
    })
    .join("\n\n");

  const body = `${classDec}\nexport class ${className} {\n${indent(propsSrc)}\n}`;

  return `${header}${body}\n`;
}

function indent(str: string, spaces = 2) {
  if (!str) return "";
  const pad = " ".repeat(spaces);
  return str
    .split("\n")
    .map((l) => (l ? pad + l : l))
    .join("\n");
}

function mergeIntoExisting(source: string, className: string, props: AttributeSpec[], classDecorators: DecoratorSpec[], importsFrom: string) {
  let updated = source;
  // Ensure imports
  const neededImports = unique(["model", ...props.flatMap((p) => p.decorators?.map((d) => d.name) || []), ...classDecorators.map((d) => d.name)]);
  const importRegex = new RegExp(`import \\{([^}]*)\\} from \\\"${importsFrom}\\\";`);
  const match = updated.match(importRegex);
  if (match) {
    const existing = match[1]
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
    const merged = unique([...existing, ...neededImports]).sort();
    updated = updated.replace(importRegex, `import { ${merged.join(", ")} } from "${importsFrom}";`);
  } else if (neededImports.length) {
    updated = `import { ${neededImports.sort().join(", ")} } from "${importsFrom}";\n\n` + updated;
  }

  // Ensure class decorator(s)
  const classDecBlock = [ { name: "model" }, ...classDecorators ].map(renderDecorator).join("\\n");
  const classRegex = new RegExp(`export\\s+class\\s+${className}\\s*\\{`);
  if (!updated.includes(`export class ${className}`)) {
    // append a new class
    updated = updated.trimEnd() + `\n\n${classDecBlock}\nexport class ${className} {\n}\n`;
  } else {
    // insert decorators above existing class if not present
    const lines = updated.split("\n");
    const idx = lines.findIndex((l) => classRegex.test(l));
    if (idx > 0) {
      // if previous non-empty lines don't already include model decorator, insert
      const prev = lines[idx - 1];
      if (!prev.includes(`@model`)) {
        lines.splice(idx, 0, ...classDecBlock.split("\\n"));
        updated = lines.join("\n");
      }
    }
  }

  // Merge properties: add missing ones; do not remove others here
  props.forEach((p) => {
    if (!new RegExp(`\\n\\s*(?:@[A-Za-z0-9_]+\\([^)]*\\)\\s*\\n)*\\s*${p.name}\\??:`).test(updated)) {
      const propBlock = `${(p.decorators || []).map(renderDecorator).join("\\n")}\n${p.name}${p.optional ? "?" : ""}: ${p.type};`;
      updated = updated.replace(classRegex, (m) => `${m}\n${indent(propBlock)}\n`);
    }
  });

  return updated;
}

export const createOrUpdateModelTool: Tool<undefined, CreateOrUpdateModelArgs> = {
  name: "decorator-validation/create-or-update-model",
  description: "Create a new model class file or update an existing one by adding class decorators and properties with validation decorators.",
  parameters: {} as any,
  execute: async (args: CreateOrUpdateModelArgs) => {
    const importsFrom = args.importsFrom || "@decaf-ts/decorator-validation";
    const filePath = path.resolve(args.filePath);
    const exists = fileExists(filePath);

    const src = exists ? readTextFile(filePath)! : "";
    const content = exists && !args.overwrite
      ? mergeIntoExisting(src, args.className, args.properties || [], args.classDecorators || [], importsFrom)
      : generateModelSource(args.className, args.properties || [], args.classDecorators || [], importsFrom);

    writeTextFile(filePath, content);
    return { filePath, className: args.className, created: !exists || !!args.overwrite };
  },
};
